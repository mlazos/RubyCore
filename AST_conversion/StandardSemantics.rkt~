
#lang racket
(require redex)

(define-language PFL
  (P (postfix N Q))
  
  (Q (C ...))
  (C N
     pop
     swap
     A
     R
     nget
     sel
     exec
     Q)
  (A add sub mul div rem)
  (R lt eq gt)
  (N number)

  (V N Q)
  (S (V ...))

  (Inputs (N ...))
  (CF (Q S))
  (FS (N V ...))
  (FC (() FS))
  (Ans N))

(define-metafunction PFL
  IF : P Inputs -> CF
  [(IF (postfix N Q) (N_i ...))
   (Q (N_i ...))
   (side-condition (= (term N) (length (term (N_i ...)))))]
  [(IF _ _)
   (() ())])

(define-metafunction PFL
  OF : FS -> Ans
  [(OF () (N V ...))
   N])

(define postfix-red
  (reduction-relation
   PFL #:domain CF
   (--> ((N C ...) S)
        ((C ...) (N . S))
        PF-Num)
   (--> ((Q C ...) S)
        ((C ...) (Q . S))
        PF-CmdSeq)
   (--> ((pop C ...) (V_f V_r ...))
        ((C ...) (V_r ...))
        PF-Pop)
   (--> ((swap C ...) (V_1 V_2 V_r ...))
        ((C ...) (V_2 V_1 V_r ...))
        PF-Swap)
   (--> ((sel C ...) (V_f V_t 0 V_r ...))
        ((C ...) (V_f V_r ...))
        PF-SelFalse)
   (--> ((sel C ...) (V_f V_t N V_r ...))
        ((C ...) (V_t V_r ...))
        (side-condition (not (zero? (term N))))
        PF-SelTrue)
   (--> ((exec C ...) ((C_Q ...) V_r ...))
        ((C_Q ... C ...) (V_r ...))
        PF-Exec)
   (--> ((A C ...) (N_1 N_2 V_r ...))
        ((C ...) (N_ans V_r ...))
        (where N_ans (calculate A N_1 N_2))
        PF-Arith)
   (--> ((R C ...) (N_1 N_2 V_r ...))
        ((C ...) (N_ans V_r ...))
        (where N_ans (compare R N_1 N_2))
        PF-Rel)
   (--> ((nget C ...) (N_i V_r ...))
        ((C ...) (V_ans V_r ...))
        (side-condition (and (> (term N_i) 0) (<= (term N_i) (length (term (V_r ...))))))
        (where V_ans ,(list-ref (term (V_r ...)) (sub1 (term N_i))))
        PF-Nget)))

(define-metafunction PFL
  calculate : A N N -> N
  [(calculate add N_1 N_2)
   ,(+ (term N_1) (term N_2))]
  [(calculate sub N_1 N_2)
   ,(- (term N_1) (term N_2))]
  [(calculate mul N_1 N_2)
   ,(* (term N_1) (term N_2))]
  [(calculate div N_1 N_2)
   ,(quotient (term N_1) (term N_2))]
  [(calculate rem N_1 N_2)
   ,(remainder (term N_1) (term N_2))])

(define-metafunction PFL
  compare : R N N -> N
  [(compare lt N_1 N_2)
   ,(if (< (term N_1) (term N_2)) 1 0)]
  [(compare eq N_1 N_2)
   ,(if (= (term N_1) (term N_2)) 1 0)]
  [(compare gt N_1 N_2)
   ,(if (> (term N_1) (term N_2)) 1 0)])